<!DOCTYPE html>
<html>
<head>
<title>Hashing Techniques</title>

<style>
body{
    font-family: Arial, sans-serif;
    margin:20px;
    background-color:#f4f6f9;
}
h1{
    text-align:center;
    color:#0a2a66;
}
h2{
    background:#0a2a66;
    color:white;
    padding:8px;
}
.section{
    background:white;
    padding:15px;
    margin-bottom:25px;
    border-radius:8px;
    box-shadow:0 0 10px rgba(0,0,0,0.1);
}
img{
    width:700px;
    max-width:100%;
    display:block;
    margin:20px auto;
    border-radius:10px;
    box-shadow:0 5px 15px rgba(0,0,0,0.2);
}
table{
    width:100%;
    border-collapse:collapse;
    margin-top:10px;
}
table, th, td{
    border:1px solid black;
}
th{
    background:#d9e3ff;
}
th, td{
    padding:8px;
    text-align:center;
}
.collision{
    background-color:#ffb3b3;
    font-weight:bold;
}
pre{
    background:#111;
    color:#0f0;
    padding:10px;
    overflow:auto;
}
</style>
</head>

<body>

<h1>Hashing Techniques in Data Structures</h1>

<!-- 1. What is Hashing -->
<div class="section">
<h2>1. What is Hashing?</h2>
<p><b>Definition:</b> Hashing is a technique used to map large data sets into smaller tables using a hash function that generates an index.</p>
<img src="https://findtodaysnotes.wordpress.com/wp-content/uploads/2024/02/image.png">
<p><b>Real Time Biotechnology Usage:</b> Used in genomic databases, DNA indexing systems, protein sequence search systems like BLAST.</p>

<pre>
/* Basic Hash Table Implementation */
#include<stdio.h>
#define SIZE 10
int hashTable[SIZE];

int hash(int key){
    return key % SIZE;
}

void insert(int key){
    int index = hash(key);
    hashTable[index] = key;
}

int main(){
    insert(25);
    insert(35);
    return 0;
}
</pre>
</div>

<!-- 2. Division Method -->
<div class="section">
<h2>2. Division Method</h2>
<p><b>Definition:</b> h(k) = k mod m</p>
<img src="https://findtodaysnotes.wordpress.com/wp-content/uploads/2024/02/image-1.png">

<table>
<tr>
<th>Element</th>
<th>Formula</th>
<th>Index</th>
<th>Collision</th>
</tr>

<tr><td>12</td><td>12 % 10</td><td>2</td><td>No</td></tr>
<tr><td>22</td><td>22 % 10</td><td>2</td><td class="collision">Yes</td></tr>
<tr><td>32</td><td>32 % 10</td><td>2</td><td class="collision">Yes</td></tr>
<tr><td>45</td><td>45 % 10</td><td>5</td><td>No</td></tr>
<tr><td>55</td><td>55 % 10</td><td>5</td><td class="collision">Yes</td></tr>
<tr><td>65</td><td>65 % 10</td><td>5</td><td class="collision">Yes</td></tr>
<tr><td>78</td><td>78 % 10</td><td>8</td><td>No</td></tr>
<tr><td>88</td><td>88 % 10</td><td>8</td><td class="collision">Yes</td></tr>
<tr><td>99</td><td>99 % 10</td><td>9</td><td>No</td></tr>
<tr><td>19</td><td>19 % 10</td><td>9</td><td class="collision">Yes</td></tr>
</table>

<p><b>Biotechnology Usage:</b> Used in DNA fragment storage systems and genome indexing.</p>

<pre>
#include<stdio.h>
#define SIZE 10
int table[SIZE];

int hash(int key){
    return key % SIZE;
}

void insert(int key){
    int index = hash(key);
    while(table[index] != 0){
        index = (index + 1) % SIZE;
    }
    table[index] = key;
}
</pre>
</div>

<!-- 3. Mid Square -->
<div class="section">
<h2>3. Mid-Square Method</h2>
<p><b>Definition:</b> Square the key and extract middle digits.</p>
<img src="https://image.slidesharecdn.com/unit-1-hashing-240126081516-8d9b5179/75/Hashing-techniques-Hashing-function-Collision-detection-techniques-19-2048.jpg">

<table>
<tr><th>Element</th><th>Formula</th><th>Index</th><th>Collision</th></tr>
<tr><td>11</td><td>11²=121 → 2</td><td>2</td><td>No</td></tr>
<tr><td>21</td><td>21²=441 → 4</td><td>4</td><td>No</td></tr>
<tr><td>31</td><td>31²=961 → 6</td><td>6</td><td>No</td></tr>
<tr><td>41</td><td>41²=1681 → 8</td><td>8</td><td>No</td></tr>
<tr><td>51</td><td>51²=2601 → 0</td><td>0</td><td>No</td></tr>
<tr><td>61</td><td>61²=3721 → 2</td><td>2</td><td class="collision">Yes</td></tr>
<tr><td>71</td><td>71²=5041 → 4</td><td>4</td><td class="collision">Yes</td></tr>
<tr><td>81</td><td>81²=6561 → 6</td><td>6</td><td class="collision">Yes</td></tr>
<tr><td>91</td><td>91²=8281 → 8</td><td>8</td><td class="collision">Yes</td></tr>
<tr><td>13</td><td>13²=169 → 6</td><td>6</td><td class="collision">Yes</td></tr>
</table>

<p><b>Biotechnology Usage:</b> Used in molecular sequence indexing.</p>

<pre>
int hash(int key){
    int square = key * key;
    return (square/10) % 10;
}
</pre>
</div>

<!-- 4. Folded Method -->
<div class="section">
<h2>4. Folded Method</h2>
<p><b>Definition:</b> Split key into parts and sum them.</p>
<img src="https://i.imgur.com/viW0ldL.png">

<table>
<tr><th>Element</th><th>Formula</th><th>Index</th><th>Collision</th></tr>
<tr><td>1234</td><td>12+34=46 →6</td><td>6</td><td>No</td></tr>
<tr><td>2345</td><td>23+45=68 →8</td><td>8</td><td>No</td></tr>
<tr><td>3456</td><td>34+56=90 →0</td><td>0</td><td>No</td></tr>
<tr><td>4567</td><td>45+67=112 →2</td><td>2</td><td>No</td></tr>
<tr><td>5678</td><td>56+78=134 →4</td><td>4</td><td>No</td></tr>
<tr><td>6789</td><td>67+89=156 →6</td><td>6</td><td class="collision">Yes</td></tr>
<tr><td>7890</td><td>78+90=168 →8</td><td>8</td><td class="collision">Yes</td></tr>
<tr><td>8901</td><td>89+01=90 →0</td><td>0</td><td class="collision">Yes</td></tr>
<tr><td>9012</td><td>90+12=102 →2</td><td>2</td><td class="collision">Yes</td></tr>
<tr><td>1122</td><td>11+22=33 →3</td><td>3</td><td>No</td></tr>
</table>

<p><b>Biotechnology Usage:</b> Used in chromosome ID mapping systems.</p>

<pre>
int hash(int key){
    int part1 = key / 100;
    int part2 = key % 100;
    return (part1 + part2) % 10;
}
</pre>
</div>

<!-- 5. Multiplication Method -->
<div class="section">
<h2>5. Multiplication Method</h2>
<p><b>Definition:</b> h(k) = floor(m (kA mod 1))</p>
<img src="https://ibpublicimages.s3-us-west-2.amazonaws.com/tutorial/hashing13.jpg">

<table>
<tr><th>Element</th><th>Formula</th><th>Index</th><th>Collision</th></tr>
<tr><td>10</td><td>floor(10*(10*0.618 mod1))</td><td>8</td><td>No</td></tr>
<tr><td>20</td><td>floor(10*(20*0.618 mod1))</td><td>6</td><td>No</td></tr>
<tr><td>30</td><td>floor(10*(30*0.618 mod1))</td><td>4</td><td>No</td></tr>
<tr><td>40</td><td>floor(10*(40*0.618 mod1))</td><td>2</td><td>No</td></tr>
<tr><td>50</td><td>floor(10*(50*0.618 mod1))</td><td>0</td><td>No</td></tr>
<tr><td>60</td><td>floor(10*(60*0.618 mod1))</td><td>8</td><td class="collision">Yes</td></tr>
<tr><td>70</td><td>floor(10*(70*0.618 mod1))</td><td>6</td><td class="collision">Yes</td></tr>
<tr><td>80</td><td>floor(10*(80*0.618 mod1))</td><td>4</td><td class="collision">Yes</td></tr>
<tr><td>90</td><td>floor(10*(90*0.618 mod1))</td><td>2</td><td class="collision">Yes</td></tr>
<tr><td>100</td><td>floor(10*(100*0.618 mod1))</td><td>0</td><td class="collision">Yes</td></tr>
</table>

<p><b>Biotechnology Usage:</b> Used in high-speed genome indexing and drug discovery databases.</p>

<pre>
int hash(int key){
    float A = 0.618;
    return (int)(10 * ((key * A) - (int)(key * A)));
}
</pre>
</div>

<!-- Theoretical Overview -->
<div class="section">
<h2>Theoretical Overview: How to Overcome Collisions</h2>

<p><b>Collision Resolution Techniques:</b></p>

<ul>
<li><b>1. Linear Probing:</b> Find next empty slot sequentially.</li>
<li><b>2. Quadratic Probing:</b> Use quadratic formula for new index.</li>
<li><b>3. Double Hashing:</b> Use second hash function.</li>
<li><b>4. Chaining:</b> Use linked list at each index.</li>
<li><b>5. Rehashing:</b> Increase table size and recompute.</li>
</ul>

<p>In biotechnology systems like DNA sequence databases and protein indexing, chaining and double hashing are widely used to efficiently manage large biological datasets.</p>

</div>

</body>
</html>
